import struct
from socket import *


class BufferedTCPEchoServer(object):
    def __init__(self, host='', port=36001, buffer_size=1024):
        self.buffer_size = buffer_size
        # This variable is used to tell the server when it should shut down. Our implementation of this server is centered
        # around one or more while loops that keeps the server listening for new connection requests and new messages from
        # a connected client. This should continue forever, or until this self.keep_running is set to False. My testing
        # code will use self.keep_running to shutdown the server for one test case 
        self.keep_running = True
        self.fixed_header_length = 4
        self.ip_address = host
        self.tcp_server = socket(AF_INET, SOCK_STREAM)
        self.tcp_server.bind((host, port))

    # This function starts the server listening for new connections and new messages. It initiates the core loop of our
    # server, where we loop continuously listening for a new connection, or if we are already connected, listening for a new
    # message. I recommend breaking the functionality up into helper functions
    # Remember that this server can only talk to one connected client at a time. We'll implement a server that
    # can connect to multiple clients at once in a future project.

    def start(self):
        while self.keep_running is True:
            try:
                client_connected = True
                self.tcp_server.listen(5)
                print('SERVER: Listening...')
                self.tcp_server, ipaddress = self.tcp_server.accept()
                while client_connected:
                    first_part = self.tcp_server.recv(self.fixed_header_length)
                    if first_part:
                        length = struct.unpack('!I', first_part)[0]
                        payload = b''
                        while len(payload) < length:
                            self.buffer_size = min(self.buffer_size, length - len(payload))
                            parts = self.tcp_server.recv(self.buffer_size)
                            payload += parts

                        decode_message = payload.decode()
                        print('SERVER: Message received...')
                        sliced_message = decode_message[10:]
                        data = struct.pack('!I' + str(len(sliced_message)) + 's', len(sliced_message),                                               sliced_message.encode())
                        self.tcp_server.send(data)
                    else:
                        client_connected = False
                        self.tcp_server.shutdown()
            except ConnectionResetError as e:
                client_connected = False
                print('SERVER: Client disconnect: ' + str(e))
                self.tcp_server.shutdown()

    # This method is called by the auto grader when it is ready to shut down your program. You should clean up your server socket
    # here. Note that all other sockets opened by the server also need to be closed once you are done with them. You should be closing
    # the individual client sockets generated by socket.accept() inside of your start() function
    def shutdown(self):
        print("SERVER: shutting down...")
        self.tcp_server.close()


if __name__ == "__main__":
    BufferedTCPEchoServer(host='', port=36001, buffer_size=1024).start()
